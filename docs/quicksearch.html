<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" pngtoy Classes PngImagePngToyPngToy.Chunk Tutorials Get Started Classes Classes PngImage PngToy Chunk × Search results Close Epistemex at GitHub "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" pngtoy Classes PngImagePngToyPngToy.Chunk Tutorials Get Started Tutorials Classes PngImage PngToy Chunk × Search results Close Epistemex at GitHub "},"index.html":{"id":"index.html","title":"Index","body":" pngtoy Classes PngImagePngToyPngToy.Chunk Tutorials Get Started pngtoyLow-level implementation of PNG file parser/reader/decoder using JavaScript on client size. Why this when browsers already parses PNG files? The browser will simply load and convert any PNG type into RGBA bitmaps. It may also apply ICC and gamma correction to the image resulting in different pixel values than in the original bitmap. We won't have access to the internals such as chunks and meta-data, or the raw bitmap. pngtoy is for special case scenarios where you need to work with the original bitmap as-is and you need the original pixel values and format (i.e. no gamma, no ICC, indexed, 16-bit, grayscale etc.). This will also keep the bitmap values consistent across browsers as some browser support ICC, gamma, others don't. There is also the risk that using a canvas can alter the bitmap values slightly due to rounding errors in the pre-multiplying process (getImageData(), putImageData()). pngtoy can be used to analyse PNG files, extract special information such as header, chunks, texts and other data, or to reduce file size, or as a tool to in an attempt to repair a PNG file, add or remove chunks, and so forth. pngtoy attempts to read all formats specified by the W3C standard. pngtoy can be used to analyse and to clean up PNG files by stripping unnecessary chunks and rebuild a file you can save as new. Comes with a built-in method to produce a new minimal PNG version of the original file. pngtoy let you just parse the chunks without decompressing and decoding any data. Features Supports 8-bit, 16-bit, indexed, bit-planes, grayscale, rgb, rgba, transparency and (interlaced). Strict parsing conforming to the standard (can be turned off for error correction purposes) CRC-32 checking for each chunk (can be turned off for error correction purposes) Using typed arrays for best performance Fast gzip implementation Non UI-blocking asynchronous block based decoding and format converting Access to chunks without the need to decompress or decode bitmaps Access to all stages (raw unfiltered buffer, filtered original format, converted to RGBA) Apply gamma to converted bitmap (file, display and optional user gamma) Handles aspect ratio correctly (pHYs chunk) (can be disabled) Parses compressed ancillary chunks and fields Parses extended chunks such as oFFs, sCAL, pCAL, sTER Uses promises (use Promise polyfill for IE) Can produce a minimal version of the original PNG (toMinimal()). Can be used in attempt to rescue corrupted PNG files Can load PNG files from URL, Data-URI, Object-URL, ArrayBuffer and typed array views Run the PNG test suit from the tests directory to see current status/rendering (must run from localhost in some browsers due to CORS restrictions). See known issues below. Installpngtoy can be installed in various ways: Git using HTTPS: git clone https://gitlab.com/epistemex/pngtoy.git Git using SSH: git clone git@gitlab.com:epistemex/pngtoy.git Download zip archive and extract. Download tar ball and extract. Bower: bower install pngtoy UsageCreate a new and reusable instance of pngtoy parser: var pngtoy = new PngToy([options]);Invoke asynchronous fetching of file returning a promise: pngtoy.fetch(&quot;http://url.to/png.file&quot;).then( ... );or pngtoy.fetch(arraybuffer).then( ... );Now you can extract the information you like from the current PNG file: // get and parse chunks var chunks = pngtoy.chunks; // chunk list - does not decode any data // parse individual chunks to object (all official chunks are supported) var ihdr = pngtoy.getChunk(&quot;IHDR&quot;); // return object for parsed IHDR chunk var raw = pngtoy.getChunk(&quot;IDAT&quot;); // get unfiltered but uncompressed bitmap data var palette = pngtoy.getChunk(&quot;PLTE&quot;); // get parsed palette if exists, or null var texts = pngtoy.getChunk(&quot;zTXt&quot;); // get array with parsed and uncompressed zTXt objects var stereo = pngtoy.getChunk(&quot;sTER&quot;); // get stereo mode if stereo image ... // you can also obtain private chunks but will have to parse them manually // decode pngtoy.decode(options).then(...); // get decoded bitmap in original depth and type pngtoy.bitmapToCanvas(bmp, options).then(...); // convert to canvas and apply optional gammaSee also the PngImage object which wraps the basic steps up for convenience (see docs for usage). NOTE: ALPHA version - API may change, see tests for current examples. Known issues (alpha) Interlace (Adam7) mode is currently not implemented LicenseAttribution-NonCommercial-ShareAlike 4.0 International Contact us if you need a commercial license. © 2015-2017 Epistemex × Search results Close Epistemex at GitHub "},"PngImage.html":{"id":"PngImage.html","title":"Class: PngImage","body":" pngtoy Classes PngImagePngToyPngToy.Chunk Tutorials Get Started Class: PngImage PngImage new PngImage() Emulates the Image object but will load a PNG image without applying gamma, ICC etc. The main purpose is to function as a wrapper for the various steps needed to load a PNG via low-level pngtoy. NOTE: An important distinction is that you need to pass in img.bitmap to canvas instead of just img. Properties: Name Type Description image * canvas holding the decoded image (use this to insert into DOM or for drawing) src * URL, Data-URI, Object-URL, ArrayBuffer or typed array view onload * callback for when image loaded successfully onerror * callback for errors onabort * callback for abort (not used in this object - provided for compatibility) width number width of image in pixels when loaded (read-only) height number height of image in pixels when loaded (read-only) naturalWidth number width of image in pixels when loaded (read-only) naturalHeight number height of image in pixels when loaded (read-only) pngtoy PngToy the PngToy instance handling this object complete boolean for IE compatibility, true when loaded × Search results Close Epistemex at GitHub "},"PngToy.html":{"id":"PngToy.html","title":"Class: PngToy","body":" pngtoy Classes PngImagePngToyPngToy.Chunk Tutorials Get Started Class: PngToy PngToy new PngToy(options) Creates a new PngToy object which is used to load a PNG image off the network as raw file. It provides methods to extract chunks as parsed objects as well as decompressing, decoding and filtering the bitmap. Parameters: Name Type Description options object options Properties Name Type Argument Default Description doCRC boolean &lt;optional&gt; true enable/disable CRC-32 check for chunks (useful for repairing PNG files) allowInvalid boolean &lt;optional&gt; false less strict passing allowing invalid data/chunks (useful for repairing PNG files) beforeSend function &lt;optional&gt; callback allowing setting headers before making xhr request. Classes Chunk Members buffer :ArrayBuffer The fetched buffer (the raw file bytes). Type: ArrayBuffer chunks :Array Array holding all the chunks objects. These can be used to manually parse the file. Type: Array url :* The URL that has been fetched. Type: * view :DataView The view used for the file buffer. Type: DataView Methods convertToCanvas(bmp [, options]) Convert a bitmap from decode() to a canvas element. After the conversion the canvas element is handed to the callback in the promise as sole argument. Parameters: Name Type Argument Description bmp * bitmap object returned from decode() options * &lt;optional&gt; options are handed to convertToRGBA() see that method for details. Returns: Type Promise convertToRGBA(bmp [, options]) Convert the raw bitmap from decode() to a browser compatible RGBA bitmap. Parameters: Name Type Argument Description bmp * bitmap object returned from decode() options * &lt;optional&gt; conversion options Properties Name Type Argument Default Description ignoreAspectRatio boolean &lt;optional&gt; false ignores the pHYs chunk if present and won't scale bitmap depending on the aspect ratio described in that chunk. useGamma boolean &lt;optional&gt; false use embedded gamma value from the gAMA chunk (if present) in the conversion Returns: passes a new bitmap object holding the RGBA bitmap, width and height as well as aspect ratio Type Promise decode() Decodes the filtered bitmap from the PNG to a RAW but filtered bitmap of same byte width and depth as well as byte-order. Passes a bitmap object as argument to the promise when done. The decoding is asynchronous. Call this method after fetch() has been used. The resolve function will receive a bitmap as argument, if rejected a string containing the error will be passed. The bitmap contains the filtered bitmap as well as some key information (additional information is extracted from the chunks). Depending on the original format you will have access to either a unsigned 8-bit buffer or a unsigned 16-bit buffer. To read a single pixel from those buffers use the formula: var pos = width * y + x;Then read the actual pixel from the buffer: var pixel = result.bitmap[pos];For 8-bit the pixel will be in the range [0, 255] while the 16-bit value will be in the range [0, 65535]. You can quickly convert the 16-bit value to 8-bit by doing: var p8 = p16&gt;&gt;&gt;8;And for a more accurate result: var p8 = Math.round(p16 / 256);Note: notice that the byte-order is big-endian. You need to swap the bytes manually or use a DataView instead to get the correct value. Returns: Type Promise fetch(src) Start loading a PNG image from an URL or an ArrayBuffer or typed array. For URL the CORS restrictions apply. It will call the resolve function with a bitmap representing the raw unfiltered bitmap. Pass this bitmap object to decode() to get a raw filtered bitmap, and further to convert() to get a RGBA bitmap. Parameters: Name Type Description src * url to PNG image (URL, Data-URI, Object-URL), or ArrayBuffer, typed array view holding the raw preloaded PNG bytes Returns: Type Promise getChunk() Get a parsed version of the named chunk. An object is returned with properties representing the specifics of this chunk. If no chunks are present null will be returned. Returns: Type * | null getGammaLUT( [fileGamma] [, dispGamma] [, userGamma]) Creates a look-up table (LUT) for the provided file gamma, and optionally display and user gamma. Display gamma is usually either 2.2 (Windows, Linux) or 1.8 (older Mac). It is used internally but is provided if you want to apply gamma to the bitmap manually. NOTE that this LUT table is only producing 8-bit values. Parameters: Name Type Argument Default Description fileGamma number &lt;optional&gt; 1 dispGamma number &lt;optional&gt; 2.2 userGamma number &lt;optional&gt; 1 Returns: Type Uint8Array guessDisplayGamma() Guess the display gamma on this system, usually 2.2 (Windows, Linux) or 1.8 (Mac). If unable to detect system a default of 2.2 will be used. This is used when a raw bitmap is converted to a RGBA bitmap and gamma is enabled. Returns: Type number toMinimal( [forDownload]) Returns a Blob containing a minimal stripped down PNG version of the original file (header and data only). The method does not alter any bitmap data to reduce data size itself - it simply recompile the chunks. Parameters: Name Type Argument Default Description forDownload boolean &lt;optional&gt; false if true returns Blob set to mime-type application/octet-stream, otherwise image/png Returns: Type * × Search results Close Epistemex at GitHub "},"PngToy.Chunk.html":{"id":"PngToy.Chunk.html","title":"Class: Chunk","body":" pngtoy Classes PngImagePngToyPngToy.Chunk Tutorials Get Started Class: Chunk PngToy. Chunk new Chunk(name, offset, length, crc, buffer) Chunk object holding references to a single chunk in the PNG file. A chunk is created internally by the PngToy instance and stored in the instance.chunks array. Parameters: Name Type Description name string FourCC name of the chunk offset number offset in raw binary files in bytes. Does not include chunk header. length number length of chunk content. Does not include CRC. crc number CRC checksum (if enabled). buffer ArrayBuffer reference to PNG binary buffer for this chunk Properties: Name Type Description name string FourCC name of the chunk offset number offset in raw binary files in bytes. Does not include chunk header. length number length of chunk content. Does not include CRC. crc number CRC checksum (if enabled). crcOk boolean If CRC, if true the CRC check was OK isCritical boolean chunk type critical (required) isPrivate boolean chunk type is private type isReserved boolean chunk type is reserved isCopySafe boolean chunk type is copy-safe (see official PNG documentation) buffer ArrayBuffer reference to PNG binary buffer for this chunk Methods getRaw( [includeContainer]) Get the raw binary data as Uint8Array() including or excluding the chunk container. Parameters: Name Type Argument Default Description includeContainer boolean &lt;optional&gt; false include chunk container (size, name, data, crc) if true, if false only the chunk content is returned. Returns: Type Uint8Array × Search results Close Epistemex at GitHub "},"tutorial-Get Started.html":{"id":"tutorial-Get Started.html","title":"Tutorial: Get Started","body":" pngtoy Classes PngImagePngToyPngToy.Chunk Tutorials Get Started Get Started PngToy is a low-level implementation of a PNG image file parser which gives you access to all the inner workings of a PNG file and its structure. For this reasons there are some more steps that needs to be taken in order to get to the various data and stages of a PNG file. You can access the raw chunks, the raw unfiltered bitmap, the decoded bitmap, the converted bitmap, chunks and so forth - leaving you in full control. If you are simply interested in getting the raw PNG file with an unaltered RGBA bitmap, see the PngImage wrapper which embeds the following steps for you (you will still have access to the instance processing the image via the pngtoy property of the PngImage instance). The load process is as follows: Create a PngToy instance fetch() the data using either URL, Data-URI, Object-URL, ArrayBuffer or a typed array view decode() the raw unfiltered bitmap into the original intended bitmap format (raw) optionally convert() the bitmap to RGBA and/or canvas which can handle all the valid PNG bitmap formats if you don't want to do this yourself. For each steps the following happens: fetch() will in addition to loading from an URL, validate the PNG file and map the various chunks. After this step you can access all the raw internals including the unfiltered bitmap using the getChunk() call. decode() will filter the bitmap. By filter we mean apply the scanline filters which is defined by the encoder. The result is a bitmap which can now be iterated in raw form. This means you have either 8-bit, 16-bit, bit-plane formats etc. and will have manually convert if you need it in a different format. convert() step will convert the data into standard 8-bit RGBA format. In our example directly to a canvas element (convertToCanvas()) but you can of course convert to a separate buffer using convertToRGBA() instead. ExampleSee a running example using the file tests/test_buffer.html. Load a PNG file from &lt;input type=file&gt; tag: HTML &lt;script src=&quot;pngtoy.min.js&quot;&gt;&lt;/script&gt; &lt;label&gt;Select a PNG from local drive: &lt;input type=&quot;file&quot;&gt;&lt;/label&gt;&lt;br&gt;JavaScript // create an instance var pngtoy = new PngToy(); // handle user selected file document.querySelector(&quot;input&quot;).onchange = function() { // assumes a PNG file is picked! (test use only) // convert File blob to ArrayBuffer var fr = new FileReader(); fr.onload = function() { // we have the ArrayBuffer var buffer = this.result; // provide buffer to fetch() which will validate the file type // as well as parsing the chunk structure. pngtoy.fetch(buffer).then(decode, error) }; // start loading File as ArrayBuffer fr.readAsArrayBuffer(this.files[0]) }; // At this stage we have access to the chunk list and the raw content of each. // First additional step is to decode the raw unfiltered bitmap into a raw filtered bitmap // to make it more useful. Note: all image data is in big-endian format. function decode(png) { pngtoy.decode(png).then(convert, error); } // Now we can choose what we want to do with the data, here simply // convert it to a RGBA canvas (independent of original bitmap format). function convert(png) { pngtoy.convertToCanvas(png, {}).then(show, error); } // show the result function show(canvas) { document.body.appendChild(canvas) } // common error handler function error(err) {alert(&quot;Could not load PNG file: &quot; + err)}After we have decoded the image (decode() step) we are free to choose the next step for our needs. Maybe we need to access 16-bit grayscale data as-is and so forth. Note that the conversion to canvas preserves the original bitmap values as far as possible. We recommend reading the bitmap directly from the PngToy instance however, as this will guarantee unaltered values, especially in the case of non-opaque alpha channel which may be altered when converted to canvas by the browser implementation (in the pre-multiplying process). The getChunk() call will parse all official chunks structures into an convenient object for you (see documentation and source for details). Any private chunk however will be given in raw binary form. Each chunk exist in a chunk-list containing the binary position and length if you want to parse the official chunks manually. Access point for the chunk-list is found via the property instance.chunks. × Search results Close Epistemex at GitHub "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
